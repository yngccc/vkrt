#version 460

#extension GL_GOOGLE_include_directive : require
#include "rayTraceCommon.glsl"

layout(push_constant) uniform pushConstant {
	mat4 screenToWorldMat;
	vec4 eyePos;
	uint accumulatedFrameCount;
};

vec3 getPixelWorldPos(in uvec2 resolution, in uvec2 pixelIndex) {
	vec2 pixelCenterIndex = vec2(pixelIndex) + vec2(0.5, 0.5);
	vec2 screenPos = (pixelCenterIndex / vec2(resolution)) * 2.0 - 1.0;
	vec4 world = screenToWorldMat * vec4(screenPos, 0.0, 1.0);
	return world.xyz / world.w;
}

layout(location = 0) rayPayloadEXT PrimaryRayPayload primaryRayPayload;

uint rngSeed;

void main() {
	uvec2 resolution = gl_LaunchSizeEXT.xy;
	uvec2 pixelIndex = gl_LaunchIDEXT.xy;

	vec3 rayDir = normalize(getPixelWorldPos(resolution, pixelIndex) - eyePos.xyz);
	traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, eyePos.xyz, 0, rayDir, 1000, 0);

	rngSeed = (pixelIndex.x * 1973 + pixelIndex.y * 9277 + accumulatedFrameCount * 26699) | 1;
	
	if (accumulatedFrameCount == 0) {
		imageStore(accumulationColorBuffer, ivec2(pixelIndex), vec4(primaryRayPayload.color, 0));
		imageStore(colorBuffer, ivec2(pixelIndex), vec4(primaryRayPayload.color, 0));
	}
	else {
		vec3 color = vec3(imageLoad(accumulationColorBuffer, ivec2(pixelIndex)));
		color += primaryRayPayload.color;
		imageStore(accumulationColorBuffer, ivec2(pixelIndex), vec4(color, 0));
		color /= accumulatedFrameCount;
		imageStore(colorBuffer, ivec2(pixelIndex), vec4(color, 0));
	}
}
